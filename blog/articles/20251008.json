{"title": {"ja": "新しいソートアルゴリズム...？", "en": "New sort algorithm?"}, "content": {"ja": "<p>今日は、ちょっとした思い付きについて書こうと思う。<br />\n(多分)新しいソートアルゴリズムを思いついてしまったかもしれない。\nロジックとしてはこんな感じ↓  </p>\n<pre class=\"codehilite\"><code class=\"language-Python\">def sort(iterable):\n    iterables_list = [iterable,]\n    print(iterables_list)\n    while len(iterables_list[-1]) &gt; 1:\n        iterables_list.append([])\n        print(&quot;a&quot;, iterables_list)\n        i = 0\n        while i &lt; len(iterables_list[-2])-1:\n            if iterables_list[-2][i] &gt; iterables_list[-2][i+1]:\n                iterables_list[-1].append(iterables_list[-2][i+1])\n                iterables_list[-2].pop(i+1)\n                print(&quot;b&quot;, iterables_list)\n            else:\n                i += 1\n        print(&quot;c&quot;, iterables_list)\n\n    if len(iterables_list[-1]) == 0:\n        iterables_list.pop()\n\n    while len(iterables_list) &gt; 1:\n        i = 0\n        while len(iterables_list[-1]) &gt; 0:\n            if iterables_list[-1][0] &lt; iterables_list[-2][i]:\n                iterables_list[-2].insert(i, iterables_list[-1][0])\n                iterables_list[-1].pop(0)\n                print(&quot;d&quot;, iterables_list)\n            else:\n                i += 1\n        iterables_list.pop()\n        print(&quot;e&quot;, iterables_list)\n    return iterables_list[0]\n</code></pre>\n\n<p>このアルゴリズムは、分離と結合の大きく二段階に分けられる。<br />\n最初に分離。順序から外れた要素を次のレイヤーへと送り、全てのレイヤーの順序が揃うまで続ける。<br />\nレイヤー分けが終わったら、最下位のレイヤーから一つ上位のレイヤーへと要素を挿入していく。<br />\n最速のケースは元から順序が揃っていた場合、最悪のケースは元が完全に逆順であった場合だと思う。<br />\n果たしてこれは既出なのだろうか？完全新規なのだろうか？</p>", "en": "<p>Today, I'd like to talk about a my inspiration.<br />\nI (maybe) found new sort algorithm.\nThe source is below.  </p>\n<pre class=\"codehilite\"><code class=\"language-Python\">def sort(iterable):\n    iterables_list = [iterable,]\n    print(iterables_list)\n    while len(iterables_list[-1]) &gt; 1:\n        iterables_list.append([])\n        print(&quot;a&quot;, iterables_list)\n        i = 0\n        while i &lt; len(iterables_list[-2])-1:\n            if iterables_list[-2][i] &gt; iterables_list[-2][i+1]:\n                iterables_list[-1].append(iterables_list[-2][i+1])\n                iterables_list[-2].pop(i+1)\n                print(&quot;b&quot;, iterables_list)\n            else:\n                i += 1\n        print(&quot;c&quot;, iterables_list)\n\n    if len(iterables_list[-1]) == 0:\n        iterables_list.pop()\n\n    while len(iterables_list) &gt; 1:\n        i = 0\n        while len(iterables_list[-1]) &gt; 0:\n            if iterables_list[-1][0] &lt; iterables_list[-2][i]:\n                iterables_list[-2].insert(i, iterables_list[-1][0])\n                iterables_list[-1].pop(0)\n                print(&quot;d&quot;, iterables_list)\n            else:\n                i += 1\n        iterables_list.pop()\n        print(&quot;e&quot;, iterables_list)\n    return iterables_list[0]\n</code></pre>\n\n<p>This algorithm has two steps, purging and marging.<br />\nThe first step, purging, this puts elements that aren't in order into the next layer.  After the all of layers are sorted, marge them from the last layer.<br />\nThe best case is all of the elements are in ordered, and the worst case is all of elements are inversed.<br />\nIs this exactly new one?</p>"}}